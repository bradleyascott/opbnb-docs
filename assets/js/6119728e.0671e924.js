"use strict";(self.webpackChunkopbnb_docs=self.webpackChunkopbnb_docs||[]).push([[886],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(a),h=r,m=p["".concat(l,".").concat(h)]||p[h]||u[h]||o;return a?n.createElement(m,i(i({ref:t},d),{},{components:a})):n.createElement(m,i({ref:t},d))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},16444:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=a(87462),r=(a(67294),a(3905));const o={sidebar_label:"Best Practices for opBNB Node Configuration",description:"Comprehensive Manual for Operating an opBNB Node Utilizing Best Practices"},i="Best Practices for opBNB Node Configuration",s={unversionedId:"tutorials/run-nodes-best-practices",id:"tutorials/run-nodes-best-practices",title:"Best Practices for opBNB Node Configuration",description:"Comprehensive Manual for Operating an opBNB Node Utilizing Best Practices",source:"@site/docs/tutorials/run-nodes-best-practices.md",sourceDirName:"tutorials",slug:"/tutorials/run-nodes-best-practices",permalink:"/opbnb-docs/docs/tutorials/run-nodes-best-practices",draft:!1,editUrl:"https://github.com/bnb-chain/opbnb-docs/blob/main/docs/tutorials/run-nodes-best-practices.md",tags:[],version:"current",frontMatter:{sidebar_label:"Best Practices for opBNB Node Configuration",description:"Comprehensive Manual for Operating an opBNB Node Utilizing Best Practices"},sidebar:"tutorials",previous:{title:"Run Local Dev Environment",permalink:"/opbnb-docs/docs/tutorials/running-a-local-development-environment"},next:{title:"Run Local Mainnet or Testnet Node",permalink:"/opbnb-docs/docs/tutorials/running-a-local-node"}},l={},c=[{value:"Selecting the Appropriate Mode and Storage Scheme",id:"selecting-the-appropriate-mode-and-storage-scheme",level:2},{value:"Fast Node",id:"fast-node",level:3},{value:"Full Node",id:"full-node",level:3},{value:"Archive Node(with op-reth)",id:"archive-nodewith-op-reth",level:3},{value:"Snapshots",id:"snapshots",level:2},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Running Server as a Daemon",id:"running-server-as-a-daemon",level:2},{value:"Security",id:"security",level:2},{value:"Securing Your Full Node RPC from Hackers",id:"securing-your-full-node-rpc-from-hackers",level:3},{value:"Software Vulnerabilities",id:"software-vulnerabilities",level:3},{value:"FAQ",id:"faq",level:2},{value:"Why does my node experience offline status or block height lag after an abrupt termination?",id:"why-does-my-node-experience-offline-status-or-block-height-lag-after-an-abrupt-termination",level:3}],d={toc:c};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"best-practices-for-opbnb-node-configuration"},"Best Practices for opBNB Node Configuration"),(0,r.kt)("p",null,"This manual delineates Best practices for the configuration and operation of an opBNB Node."),(0,r.kt)("h2",{id:"selecting-the-appropriate-mode-and-storage-scheme"},"Selecting the Appropriate Mode and Storage Scheme"),(0,r.kt)("p",null,"opBNB accommodates various node modes: Full, Fast, and Archive.\nTwo storage schemes are available: HBSS (Hash-Based Scheme Storage) and PBSS (Path-Based Scheme Storage)."),(0,r.kt)("p",null,"The principal distinctions between them lie in their methods of preserving history trie data."),(0,r.kt)("p",null,"The Merkle Patricia Trie (MPT), an advanced data structure, is adept at storing and retrieving key-value pairs with efficiency. It amalgamates the principles of a Patricia trie and a Merkle tree to forge a secure and immutable representation of data within the Ethereum Virtual Machine (EVM)."),(0,r.kt)("p",null,"The MPT endows the following capabilities:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Access to historical data: Enables retrieval of an account's balance at a specified block height, simulation of calls, and debugging of traces at particular block heights, among others."),(0,r.kt)("li",{parentName:"ul"},"Verification of Inclusion and Exclusion:\nThe MPT facilitates proofs of both inclusion and exclusion of key-value pairs, a pivotal feature for transaction verification and blockchain integrity maintenance.")),(0,r.kt)("p",null,"Nevertheless, the preservation of entire history trie data on disk can demand substantial resources and may be superfluous for certain applications. opBNB introduces diverse node modes and storage schemes to accommodate a range of requirements."),(0,r.kt)("p",null,"The variances between the modes and storage schemes are encapsulated as follows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Archive node mode conserves the complete history trie data. Full node mode archives recent trie data (128 blocks), whereas the fast node mode retains only the current state, excluding trie data.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Functions such as block, transaction, receipt, and log retrieval are supported across all node modes. Since block data is preserved in the block database, it remains unaffected by the trie data storage scheme."),(0,r.kt)("li",{parentName:"ul"},"The capability to access historical state data varies by node mode. Archive nodes support comprehensive historical state data retrieval, whereas full and fast nodes facilitate access to recent 128 blocks' state data."),(0,r.kt)("li",{parentName:"ul"},"Trie data-dependent functions like ",(0,r.kt)("inlineCode",{parentName:"li"},"eth_getProof"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"eth_getStorageAt"),", etc., are fully supported by Archive nodes. Full nodes offer queries for recent 128 blocks, whereas fast nodes lack this support."),(0,r.kt)("li",{parentName:"ul"},"Specifically, given that the transfer from Layer 2 to Layer 1 necessitates ",(0,r.kt)("inlineCode",{parentName:"li"},"eth_getProof")," data corresponding to the most recent root hash height, we have implemented certain enhancements within the full node configuration to facilitate ",(0,r.kt)("inlineCode",{parentName:"li"},"eth_getProof")," for the latest root hash height, irrespective of it surpassing the 128-block threshold. Should you require the utilization of your personal node for the assembly of withdrawal proof, the full node mode is at your disposal."))),(0,r.kt)("li",{parentName:"ul"},"PBSS archives trie nodes on disk utilizing encoded paths and specific key prefixes as keys. This method permits PBSS's Merkle Patricia Trie (MPT) to supersede older data due to the shared key between the account trie and storage trie, enabling ",(0,r.kt)("strong",{parentName:"li"},"online pruning")," and significantly ",(0,r.kt)("strong",{parentName:"li"},"diminishing data redundancy"),".",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Archive node mode is only compatible with HBSS, whereas Full and Fast node modes support both HBSS and PBSS."),(0,r.kt)("li",{parentName:"ul"},"For further details, please consult the ",(0,r.kt)("a",{parentName:"li",href:"/opbnb-docs/docs/tutorials/pbss-pebble"},"PBSS document"),".")))),(0,r.kt)("p",null,"Comparative Analysis of Node Modes and Storage Schemes:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Mode")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Full Node (PBSS)")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Full Node (HBSS)")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Fast Node")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Archive Node")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Preserve Trie Nodes")),(0,r.kt)("td",{parentName:"tr",align:null},"Latest 128 blocks"),(0,r.kt)("td",{parentName:"tr",align:null},"Latest 128 blocks"),(0,r.kt)("td",{parentName:"tr",align:null},"None"),(0,r.kt)("td",{parentName:"tr",align:null},"All")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Disk Consumption")),(0,r.kt)("td",{parentName:"tr",align:null},"Moderate-Low"),(0,r.kt)("td",{parentName:"tr",align:null},"Moderate-High"),(0,r.kt)("td",{parentName:"tr",align:null},"Lowest"),(0,r.kt)("td",{parentName:"tr",align:null},"Highest")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Auto Prune History Trie Data")),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"Not Applicable"),(0,r.kt)("td",{parentName:"tr",align:null},"Not Applicable")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Performance")),(0,r.kt)("td",{parentName:"tr",align:null},"Moderate-High"),(0,r.kt)("td",{parentName:"tr",align:null},"Moderate-Low"),(0,r.kt)("td",{parentName:"tr",align:null},"Highest"),(0,r.kt)("td",{parentName:"tr",align:null},"Lowest")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Security")),(0,r.kt)("td",{parentName:"tr",align:null},"High"),(0,r.kt)("td",{parentName:"tr",align:null},"High"),(0,r.kt)("td",{parentName:"tr",align:null},"Lower than others since it doesn't verify the state root"),(0,r.kt)("td",{parentName:"tr",align:null},"High")))),(0,r.kt)("h3",{id:"fast-node"},"Fast Node"),(0,r.kt)("p",null,"For most applications, operating a fast node is advisable. This mode maintains only the current state, sans trie data, making it suitable for tasks such as querying the current state and processing transactions."),(0,r.kt)("p",null,"To activate the fast node, include ",(0,r.kt)("inlineCode",{parentName:"p"},"--allow-insecure-no-tries")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"op-geth")," startup command."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," ./geth --config ./config.toml --datadir ./node --syncmode full  --allow-insecure-no-tries\n")),(0,r.kt)("p",null,"To prune the MPT state (e.g., when transitioning from a full to a fast node), prune the node as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"./geth snapshot insecure-prune-all --datadir ./datadir ./genesis.json\n")),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"Fast Node does not generate Trie Data when syncing.\nOnce the Fast Node is running, there is no way to switch back to Full Node.\nNeed to re-download snapshot data to restore it to Full Node.")),(0,r.kt)("p",null,"For implementation details and further information, refer to ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bnb-chain/op-geth/pull/75"},"the PR"),"."),(0,r.kt)("h3",{id:"full-node"},"Full Node"),(0,r.kt)("p",null,"Operating a full node is recommended if you require:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Enhanced security and reliability assurances. The full node meticulously executes and locally verifies all blocks."),(0,r.kt)("li",{parentName:"ul"},"The facility to query trie data of the most recent 128 blocks, such as retrieving an account's balance at a specific block height, simulating calls, and debugging traces.")),(0,r.kt)("p",null,"To enable the full node, set the ",(0,r.kt)("inlineCode",{parentName:"p"},"--syncmode full")," flag in the ",(0,r.kt)("inlineCode",{parentName:"p"},"geth")," command."),(0,r.kt)("p",null,"It is particularly advised to operate a full node with PBSS and pebble to minimize data redundancy and enhance performance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"--state.scheme path --db.engine pebble\n")),(0,r.kt)("p",null,"For comprehensive details, consult the ",(0,r.kt)("a",{parentName:"p",href:"/opbnb-docs/docs/tutorials/pbss-pebble"},"PBSS document"),"."),(0,r.kt)("h3",{id:"archive-nodewith-op-reth"},"Archive Node(with op-reth)"),(0,r.kt)("p",null,"The Archive node mode archives the entirety of history trie data.\nThis mode is apt for scenarios necessitating access to the complete history trie data, such as block explorers and analytics."),(0,r.kt)("p",null,"The current volume of history trie data approximates 3TB (as of the end of April, 2024).\nSignificant performance issues may arise in the op-geth implementation when managing extensive history trie data.\nTherefore, it is recommended to operate the archive node in conjunction with op-reth."),(0,r.kt)("p",null,"Below is an exemplary command for initiating the archive node with op-reth:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'export L2_RPC=https://opbnb-mainnet-rpc.bnbchain.org\n\nop-reth node \\\n    --datadir /server/datadir \\\n    --chain opbnb-mainnet \\\n    --rollup.sequencer-http ${L2_RPC} \\\n    --authrpc.addr "0.0.0.0" \\\n    --authrpc.port 8551 \\\n    --authrpc.jwtsecret /server/datadir/jwt.txt \\\n    --http \\\n    --http.addr "0.0.0.0" \\\n    --http.port 8545 \\\n    --ws \\\n    --ws.addr "0.0.0.0" \\\n    --ws.port 8545 \\\n    --builder.gaslimit 150000000 \\\n    --nat any\n')),(0,r.kt)("p",null,"For further particulars, visit the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bnb-chain/reth"},"op-reth GitHub repository"),"."),(0,r.kt)("h2",{id:"snapshots"},"Snapshots"),(0,r.kt)("p",null,"The latest snapshot data is accessible via the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bnb-chain/opbnb-snapshot"},"opbnb-snapshot")," repository."),(0,r.kt)("p",null,"Employing snapshot data can drastically curtail the time required for node synchronization."),(0,r.kt)("h2",{id:"performance-optimization"},"Performance Optimization"),(0,r.kt)("p",null,"In order to enhance the performance of ",(0,r.kt)("inlineCode",{parentName:"p"},"op-geth"),", it is crucial to configure the cache settings appropriately. Allocating approximately one-third of the physical memory to the cache is advisable. For instance, if the system has 64GB of physical memory, the cache setting can be configured as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"--cache 20000\n")),(0,r.kt)("p",null,"This allocation ensures that the cache is optimized for efficient use of system resources, ultimately leading to improved performance of ",(0,r.kt)("inlineCode",{parentName:"p"},"op-geth"),"."),(0,r.kt)("h2",{id:"running-server-as-a-daemon"},"Running Server as a Daemon"),(0,r.kt)("p",null,"To ensure continuous operation, it is important to keep ",(0,r.kt)("inlineCode",{parentName:"p"},"op-node")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"op-geth")," running at all times. One of the simplest and recommended solutions is to register them as systemd service. By doing so, they will automatically start upon system reboots and other relevant events, ensuring seamless operation without manual intervention."),(0,r.kt)("h2",{id:"security"},"Security"),(0,r.kt)("h3",{id:"securing-your-full-node-rpc-from-hackers"},"Securing Your Full Node RPC from Hackers"),(0,r.kt)("p",null,"It is imperative to safeguard your Full Node RPC endpoints from unauthorized access. Exposing RPC endpoints to the public network can pose security risks, making it essential to restrict access and implement appropriate security measures to prevent unauthorized intrusion."),(0,r.kt)("h3",{id:"software-vulnerabilities"},"Software Vulnerabilities"),(0,r.kt)("p",null,"To ensure the security of your node and assets, it is crucial to download software only from official sources. Additionally, it is important to consistently update the software to the latest, most secure version available. By adhering to these practices, you can mitigate the risk of potential vulnerabilities and safeguard your node and assets from security threats."),(0,r.kt)("h2",{id:"faq"},"FAQ"),(0,r.kt)("h3",{id:"why-does-my-node-experience-offline-status-or-block-height-lag-after-an-abrupt-termination"},"Why does my node experience offline status or block height lag after an abrupt termination?"),(0,r.kt)("p",null,"After running a synchronized node for an extended period of time, abruptly terminating the node(op-geth process) can result in a period of offline status upon restart. Specifically, only archived nodes are expected to quickly re-synchronize after such an event."),(0,r.kt)("p",null,"The reason for this behavior lies in the nature of Geth's functionality. When Geth experiences a crash or is not shut down gracefully, the recent state that was held in memory is lost and must be regenerated. As a result, it can take Geth a considerable amount of time to restore these states."),(0,r.kt)("p",null,"The root cause of this prolonged restoration process can be attributed to the fact that Geth does flush the state trie periodically. The frequency of this flushing is defined by the trieTimeout parameter in the configuration file (config.toml). This periodic flushing is intended to maintain consistency and integrity within the node's state, but it also contributes to the time required for state regeneration in the event of an abrupt shutdown."))}p.isMDXComponent=!0}}]);